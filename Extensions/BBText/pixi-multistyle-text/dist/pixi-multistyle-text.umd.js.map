{"version":3,"file":"pixi-multistyle-text.umd.js","sources":["../src/pixi-multistyle-text.ts"],"sourcesContent":["/// <reference types=\"pixi.js\" />\n\n\"use strict\";\n\nexport interface ExtendedTextStyle extends PIXI.TextStyleOptions {\n\tvalign?: \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\n\tdebug?: boolean;\n\ttagStyle?: \"xml\" | \"bbcode\";\n}\n\nexport interface TextStyleSet {\n\t[key: string]: ExtendedTextStyle;\n}\n\ninterface FontProperties {\n\tascent: number;\n\tdescent: number;\n\tfontSize: number;\n}\n\ninterface TextData {\n\ttext: string;\n\tstyle: ExtendedTextStyle;\n\twidth: number;\n\theight: number;\n\tfontProperties: FontProperties;\n\ttag: TagData;\n}\n\ninterface TextDrawingData {\n\ttext: string;\n\tstyle: ExtendedTextStyle;\n\tx: number;\n\ty: number;\n\twidth: number;\n\tascent: number;\n\tdescent: number;\n\ttag: TagData;\n}\n\nexport interface MstDebugOptions {\n\tspans: {\n\t\tenabled?: boolean;\n\t\tbaseline?: string;\n\t\ttop?: string;\n\t\tbottom?: string;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t};\n\tobjects: {\n\t\tenabled?: boolean;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t}\n}\n\nexport interface TagData {\n\tname: string;\n\tproperties: { [key: string]: string };\n}\n\nexport interface MstInteractionEvent extends PIXI.interaction.InteractionEvent {\n\ttargetTag: TagData;\n}\n\nconst INTERACTION_EVENTS = [\n\t\"pointerover\",\n\t\"pointerenter\",\n\t\"pointerdown\",\n\t\"pointermove\",\n\t\"pointerup\",\n\t\"pointercancel\",\n\t\"pointerout\",\n\t\"pointerleave\",\n\t\"gotpointercapture\",\n\t\"lostpointercapture\",\n\t\"mouseover\",\n\t\"mouseenter\",\n\t\"mousedown\",\n\t\"mousemove\",\n\t\"mouseup\",\n\t\"mousecancel\",\n\t\"mouseout\",\n\t\"mouseleave\",\n\t\"touchover\",\n\t\"touchenter\",\n\t\"touchdown\",\n\t\"touchmove\",\n\t\"touchup\",\n\t\"touchcancel\",\n\t\"touchout\",\n\t\"touchleave\"\n];\n\nconst TAG_STYLE = {\n\tbbcode: \"bbcode\",\n\txml: \"xml\"\n};\n\nconst TAG = {\n\tbbcode: [\"[\", \"]\"],\n\txml: [\"<\", \">\"]\n};\n\nexport default class MultiStyleText extends PIXI.Text {\n\tprivate static DEFAULT_TAG_STYLE: ExtendedTextStyle = {\n\t\talign: \"left\",\n\t\tbreakWords: false,\n\t\t// debug intentionally not included\n\t\tdropShadow: false,\n\t\tdropShadowAngle: Math.PI / 6,\n\t\tdropShadowBlur: 0,\n\t\tdropShadowColor: \"#000000\",\n\t\tdropShadowDistance: 5,\n\t\tfill: \"black\",\n\t\tfillGradientType: PIXI.TEXT_GRADIENT.LINEAR_VERTICAL,\n\t\tfontFamily: \"Arial\",\n\t\tfontSize: 26,\n\t\tfontStyle: \"normal\",\n\t\tfontVariant: \"normal\",\n\t\tfontWeight: \"normal\",\n\t\tletterSpacing: 0,\n\t\tlineHeight: 0,\n\t\tlineJoin: \"miter\",\n\t\tmiterLimit: 10,\n\t\tpadding: 0,\n\t\tstroke: \"black\",\n\t\tstrokeThickness: 0,\n\t\ttextBaseline: \"alphabetic\",\n\t\tvalign: \"baseline\",\n\t\twordWrap: false,\n\t\twordWrapWidth: 100,\n\t\ttagStyle: \"xml\"\n\t};\n\n\tpublic static debugOptions: MstDebugOptions = {\n\t\tspans: {\n\t\t\tenabled: false,\n\t\t\tbaseline: \"#44BB44\",\n\t\t\ttop: \"#BB4444\",\n\t\t\tbottom: \"#4444BB\",\n\t\t\tbounding: \"rgba(255, 255, 255, 0.1)\",\n\t\t\ttext: true\n\t\t},\n\t\tobjects: {\n\t\t\tenabled: false,\n\t\t\tbounding: \"rgba(255, 255, 255, 0.05)\",\n\t\t\ttext: true\n\t\t}\n\t};\n\n\tprivate textStyles: TextStyleSet;\n\n\tprivate hitboxes: { tag: TagData, hitbox: PIXI.Rectangle }[];\n\n\tconstructor(text: string, styles: TextStyleSet) {\n\t\tsuper(text);\n\n\t\tthis.styles = styles;\n\n\t\tINTERACTION_EVENTS.forEach((event) => {\n\t\t\tthis.on(event, (e: PIXI.interaction.InteractionEvent) => this.handleInteraction(e));\n\t\t});\n\t}\n\n\tprivate handleInteraction(e: PIXI.interaction.InteractionEvent) {\n\t\tlet ev = e as MstInteractionEvent;\n\n\t\tlet localPoint = e.data.getLocalPosition(this);\n\t\tlet targetTag = this.hitboxes.reduce((prev, hitbox) => prev !== undefined ? prev : (hitbox.hitbox.contains(localPoint.x, localPoint.y) ? hitbox : undefined), undefined);\n\t\tev.targetTag = targetTag === undefined ? undefined : targetTag.tag;\n\t}\n\n\tpublic set styles(styles: TextStyleSet) {\n\t\tthis.textStyles = {};\n\n\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\n\t\tfor (let style in styles) {\n\t\t\tif (style === \"default\") {\n\t\t\t\tthis.assign(this.textStyles[\"default\"], styles[style]);\n\t\t\t} else {\n\t\t\t\tthis.textStyles[style] = this.assign({}, styles[style]);\n\t\t\t}\n\t\t}\n\t\tif (this.textStyles.default.tagStyle === TAG_STYLE.bbcode) {\n\t\t\t// when using bbcode parsing, register a bunch of standard bbcode tags and some cool pixi ones\n\t\t\tthis.textStyles.b = this.assign({}, {fontStyle: 'bold'});\n\t\t\tthis.textStyles.i = this.assign({}, {fontStyle: 'italic'});\n\t\t\tthis.textStyles.color = this.assign({}, {fill: ''}); // an array would result in gradients\n\t\t\tthis.textStyles.outline = this.assign({}, {stroke: '', strokeThickness: 6});\n\t\t\tthis.textStyles.font = this.assign({}, {fontFamily: ''});\n\t\t\tthis.textStyles.shadow = this.assign({}, {\n\t\t\t\tdropShadowColor: '', dropShadow: true, dropShadowBlur: 3, dropShadowDistance: 3, dropShadowAngle: 2,});\n\t\t\tthis.textStyles.size = this.assign({}, {fontSize: 'px'});\n\t\t\tthis.textStyles.spacing = this.assign({}, {letterSpacing: ''});\n\t\t\tthis.textStyles.align = this.assign({}, {align: ''});\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tpublic setTagStyle(tag: string, style: ExtendedTextStyle): void {\n\t\tif (tag in this.textStyles) {\n\t\t\tthis.assign(this.textStyles[tag], style);\n\t\t} else {\n\t\t\tthis.textStyles[tag] = this.assign({}, style);\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tpublic deleteTagStyle(tag: string): void {\n\t\tif (tag === \"default\") {\n\t\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\t\t} else {\n\t\t\tdelete this.textStyles[tag];\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tprivate getTagRegex(captureName: boolean, captureMatch: boolean): RegExp {\n\t\tlet tagAlternation = Object.keys(this.textStyles).join(\"|\");\n\t\tconst { tagStyle } = this.textStyles.default;\n\n\t\tif (captureName) {\n\t\t\ttagAlternation = `(${tagAlternation})`;\n\t\t} else {\n\t\t\ttagAlternation = `(?:${tagAlternation})`;\n\t\t}\n\n\t\tlet reStr = tagStyle === TAG_STYLE.bbcode ? `\\\\${TAG.bbcode[0]}${tagAlternation}(?:\\\\=(?:[A-Za-z0-9_\\\\-\\\\#]+|'(?:[^']+|\\\\\\\\')*'))*\\\\s*\\\\${TAG.bbcode[1]}|\\\\${TAG.bbcode[0]}\\\\/${tagAlternation}\\\\s*\\\\${TAG.bbcode[1]}`\n\t\t: `\\\\${TAG.xml[0]}${tagAlternation}(?:\\\\s+[A-Za-z0-9_\\\\-]+=(?:\"(?:[^\"]+|\\\\\\\\\")*\"|'(?:[^']+|\\\\\\\\')*'))*\\\\s*\\\\${TAG.xml[1]}|\\\\${TAG.xml[0]}\\\\/${tagAlternation}\\\\s*\\\\${TAG.xml[1]}`;\n\n\t\tif (captureMatch) {\n\t\t\treStr = `(${reStr})`;\n\t\t}\n\n\t\treturn new RegExp(reStr, \"g\");\n\t}\n\n\tprivate getPropertyRegex(): RegExp {\n\t\treturn new RegExp(`([A-Za-z0-9_\\\\-]+)=(?:\"((?:[^\"]+|\\\\\\\\\")*)\"|'((?:[^']+|\\\\\\\\')*)')`, \"g\");\n\t}\n\n\tprivate getBBcodePropertyRegex(): RegExp {\n\t\treturn new RegExp(`[A-Za-z0-9_\\\\-]+=([A-Za-z0-9_\\\\-\\\\#]+)`, \"g\");\n\t}\n\n\tprivate _getTextDataPerLine (lines: string[]) {\n\t\tlet outputTextData: TextData[][] = [];\n\t\tlet re = this.getTagRegex(true, false);\n\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tlet tagStack: TagData[] = [{ name: \"default\", properties: {} }];\n\n\t\t// determine the group of word for each line\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineTextData: TextData[] = [];\n\n\t\t\t// find tags inside the string\n\t\t\tlet matches: RegExpExecArray[] = [];\n\t\t\tlet matchArray: RegExpExecArray;\n\n\t\t\twhile (matchArray = re.exec(lines[i])) {\n\t\t\t\tmatches.push(matchArray);\n\t\t\t}\n\t\t\t// if there is no match, we still need to add the line with the default style\n\t\t\tif (matches.length === 0) {\n\t\t\t\tlineTextData.push(this.createTextData(lines[i], styleStack[styleStack.length - 1], tagStack[tagStack.length - 1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We got a match! add the text with the needed style\n\t\t\t\tlet currentSearchIdx = 0;\n\t\t\t\tfor (let j = 0; j < matches.length; j++) {\n\t\t\t\t\t// if index > 0, it means we have characters before the match,\n\t\t\t\t\t// so we need to add it with the default style\n\t\t\t\t\tif (matches[j].index > currentSearchIdx) {\n\t\t\t\t\t\tlineTextData.push(this.createTextData(\n\t\t\t\t\t\t\tlines[i].substring(currentSearchIdx, matches[j].index),\n\t\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matches[j][0][1] === \"/\") { // reset the style if end of tag\n\t\t\t\t\t\tif (styleStack.length > 1) {\n\t\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t\t\ttagStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // set the current style\n\t\t\t\t\t\tlet properties: { [key: string]: string } = {};\n\t\t\t\t\t\tlet propertyRegex = this.getPropertyRegex();\n\t\t\t\t\t\tlet propertyMatch: RegExpMatchArray;\n\n\t\t\t\t\t\twhile (propertyMatch = propertyRegex.exec(matches[j][0])) {\n\t\t\t\t\t\t\tproperties[propertyMatch[1]] = propertyMatch[2] || propertyMatch[3];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttagStack.push({ name: matches[j][1], properties });\n\n\t\t\t\t\t\tconst { tagStyle } = this.textStyles.default;\n\t\t\t\t\t\t// if using bbtag style, take styling information in a different way\n\t\t\t\t\t\tif (tagStyle === TAG_STYLE.bbcode && matches[j][0].includes('=') && this.textStyles[matches[j][1]]) {\n\t\t\t\t\t\t\tconst bbcodeRegex = this.getBBcodePropertyRegex();\n\t\t\t\t\t\t\tconst bbcodeTags = bbcodeRegex.exec(matches[j][0]);\n\t\t\t\t\t\t\tlet bbStyle:{ [key: string]: string } = {};\n\t\t\t\t\t\t\tObject.entries(this.textStyles[matches[j][1]]).forEach( style => {\n\t\t\t\t\t\t\t\tbbStyle[style[0]] = typeof style[1] !== 'string'? style[1] : bbcodeTags[1] + style[1];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], bbStyle));\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[matches[j][1]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// update the current search index\n\t\t\t\t\tcurrentSearchIdx = matches[j].index + matches[j][0].length;\n\t\t\t\t}\n\n\t\t\t\t// is there any character left?\n\t\t\t\tif (currentSearchIdx < lines[i].length) {\n\t\t\t\t\tconst result = this.createTextData(\n\t\t\t\t\t\tcurrentSearchIdx ? lines[i].substring(currentSearchIdx) : lines[i],\n\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t)\n\t\t\t\t\tlineTextData.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutputTextData.push(lineTextData);\n\t\t}\n\n\t\t// don't display any incomplete tags at the end of text- good for scrolling text in games\n\t\tconst { tagStyle } = this.textStyles.default;\n\t\toutputTextData[outputTextData.length-1].map( data => {\n\t\t\tif (data.text.includes(TAG[tagStyle][0])) data.text = data.text.match(tagStyle === TAG_STYLE.bbcode ? /^(.*)\\[/ : /^(.*)\\</)[1]\t\n\t\t});\n\n\t\treturn outputTextData;\n\t}\n\n\tprivate getFontString(style: ExtendedTextStyle): string {\n\t\treturn new PIXI.TextStyle(style).toFontString();\n\t}\n\n\tprivate createTextData(text: string, style: ExtendedTextStyle, tag: TagData): TextData {\n\t\treturn {\n\t\t\ttext,\n\t\t\tstyle,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tfontProperties: undefined,\n\t\t\ttag\n\t\t};\n\t}\n\n\tprivate getDropShadowPadding(): number {\n\t\tlet maxDistance = 0;\n\t\tlet maxBlur = 0;\n\n\t\t Object.keys(this.textStyles).forEach((styleKey) => {\n\t\t\tlet { dropShadowDistance, dropShadowBlur } = this.textStyles[styleKey];\n\t\t\tmaxDistance = Math.max(maxDistance, dropShadowDistance || 0);\n\t\t\tmaxBlur = Math.max(maxBlur, dropShadowBlur || 0);\n\t\t});\n\n\t\treturn maxDistance + maxBlur;\n\t}\n\n\tpublic updateText(): void {\n\t\tif (!this.dirty) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hitboxes = [];\n\n\t\tthis.texture.baseTexture.resolution = this.resolution;\n\t\tlet textStyles = this.textStyles;\n\t\tlet outputText = this.text;\n\n\t\tif(this._style.wordWrap) {\n\t\t\toutputText = this.wordWrap(this.text);\n\t\t}\n\n\t\t// split text into lines\n\t\tlet lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n\t\t// get the text data with specific styles\n\t\tlet outputTextData = this._getTextDataPerLine(lines);\n\n\t\t// calculate text width and height\n\t\tlet lineWidths: number[] = [];\n\t\tlet lineYMins: number[] = [];\n\t\tlet lineYMaxs: number[] = [];\n\t\tlet baselines: number[] = [];\n\t\tlet maxLineWidth = 0;\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineWidth = 0;\n\t\t\tlet lineYMin = 0;\n\t\t\tlet lineYMax = 0;\n\t\t\tlet baseline = 0;\n\t\t\tfor (let j = 0; j < outputTextData[i].length; j++) {\n\t\t\t\tlet sty = outputTextData[i][j].style;\n\n\t\t\t\tthis.context.font = this.getFontString(sty);\n\n\t\t\t\t// save the width\n\t\t\t\toutputTextData[i][j].width = this.context.measureText(outputTextData[i][j].text).width;\n\n\t\t\t\tif (outputTextData[i][j].text.length !== 0) {\n\t\t\t\t\toutputTextData[i][j].width += (outputTextData[i][j].text.length - 1) * sty.letterSpacing;\n\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing before first character\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j < outputTextData[i].length - 1) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing after last character\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlineWidth += outputTextData[i][j].width;\n\n\t\t\t\t// save the font properties\n\t\t\t\toutputTextData[i][j].fontProperties = PIXI.TextMetrics.measureFont(this.context.font);\n\n\t\t\t\t// save the height\n\t\t\t\toutputTextData[i][j].height = outputTextData[i][j].fontProperties.fontSize;\n\n\t\t\t\tif (typeof sty.valign === \"number\") {\n\t\t\t\t\tlineYMin =\n\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tlineYMin,\n\t\t\t\t\t\t\tsty.valign\n\t\t\t\t\t\t\t\t- outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax =\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tlineYMax,\n\t\t\t\t\t\t\tsty.valign\n\t\t\t\t\t\t\t\t+ outputTextData[i][j].fontProperties.ascent);\n\t\t\t\t} else {\n\t\t\t\t\tlineYMin =\n\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tlineYMin,\n\t\t\t\t\t\t\t-outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax =\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tlineYMax,\n\t\t\t\t\t\t\toutputTextData[i][j].fontProperties.ascent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineWidths[i] = lineWidth;\n\t\t\tlineYMins[i] = lineYMin;\n\t\t\tlineYMaxs[i] = lineYMax;\n\t\t\tmaxLineWidth = Math.max(maxLineWidth, lineWidth);\n\t\t}\n\n\t\t// transform styles in array\n\t\tlet stylesArray = Object.keys(textStyles).map((key) => textStyles[key]);\n\n\t\tlet maxStrokeThickness = stylesArray.reduce((prev, cur) => Math.max(prev, cur.strokeThickness || 0), 0);\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\tlet totalHeight = lineYMaxs.reduce((prev, cur) => prev + cur, 0) - lineYMins.reduce((prev, cur) => prev + cur, 0);\n\n\t\t// define the right width and height\n\t\tlet width = maxLineWidth + 2 * maxStrokeThickness + 2 * dropShadowPadding;\n\t\tlet height = totalHeight + 2 * maxStrokeThickness + 2 * dropShadowPadding;\n\n\t\tthis.canvas.width = width * this.resolution;\n\t\tthis.canvas.height = height * this.resolution;\n\n\t\tthis.context.scale(this.resolution, this.resolution);\n\n\t\tthis.context.textBaseline = \"alphabetic\";\n\t\tthis.context.lineJoin = \"round\";\n\n\t\tlet basePositionY = dropShadowPadding + maxStrokeThickness;\n\n\t\tlet drawingData: TextDrawingData[] = [];\n\n\t\t// Compute the drawing data\n\t\tfor (let i = 0; i < outputTextData.length; i++) {\n\t\t\tlet line = outputTextData[i];\n\t\t\tlet linePositionX: number;\n\n\t\t\tswitch (this._style.align) {\n\t\t\t\tcase \"left\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"center\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness + (maxLineWidth - lineWidths[i]) / 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"right\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness + maxLineWidth - lineWidths[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tlet { style, text, fontProperties, width, height, tag } = line[j];\n\n\t\t\t\tlet linePositionY = basePositionY + fontProperties.ascent;\n\n\t\t\t\tswitch (style.valign) {\n\t\t\t\t\tcase \"top\":\n\t\t\t\t\t\t// no need to do anything\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"baseline\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\tlinePositionY += (lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent) / 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"bottom\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// A number - offset from baseline, positive is higher\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent - style.valign;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (style.letterSpacing === 0) {\n\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\ttag\n\t\t\t\t\t});\n\n\t\t\t\t\tlinePositionX += line[j].width;\n\t\t\t\t} else {\n\t\t\t\t\tthis.context.font = this.getFontString(line[j].style);\n\n\t\t\t\t\tfor (let k = 0; k < text.length; k++) {\n\t\t\t\t\t\tif (k > 0 || j > 0) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet charWidth = this.context.measureText(text.charAt(k)).width;\n\n\t\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\t\ttext: text.charAt(k),\n\t\t\t\t\t\t\tstyle,\n\t\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\t\twidth: charWidth,\n\t\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\t\ttag\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlinePositionX += charWidth;\n\n\t\t\t\t\t\tif (k < text.length - 1 || j < line.length - 1) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasePositionY += lineYMaxs[i] - lineYMins[i];\n\t\t}\n\n\t\tthis.context.save();\n\n\t\t// First pass: draw the shadows only\n\t\tdrawingData.forEach(({ style, text, x, y }) => {\n\t\t\tif (!style.dropShadow) {\n\t\t\t\treturn; // This text doesn't have a shadow\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet dropFillStyle = style.dropShadowColor;\n\t\t\tif (typeof dropFillStyle === \"number\") {\n\t\t\t\tdropFillStyle = PIXI.utils.hex2string(dropFillStyle);\n\t\t\t}\n\t\t\tthis.context.shadowColor = dropFillStyle;\n\t\t\tthis.context.shadowBlur = style.dropShadowBlur;\n\t\t\tthis.context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\t\t\tthis.context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\tthis.context.restore();\n\n\t\t// Second pass: draw the strokes only\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tif (style.stroke === undefined || !style.strokeThickness) {\n\t\t\t\treturn; // Skip this step if we have no stroke\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet strokeStyle = style.stroke;\n\t\t\tif (typeof strokeStyle === \"number\") {\n\t\t\t\tstrokeStyle = PIXI.utils.hex2string(strokeStyle);\n\t\t\t}\n\n\t\t\tthis.context.strokeStyle = strokeStyle;\n\t\t\tthis.context.lineWidth = style.strokeThickness;\n\n\t\t\tthis.context.strokeText(text, x, y);\n\t\t});\n\n\t\t// Third pass: draw the fills only\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tif (style.fill === undefined) {\n\t\t\t\treturn; // Skip this step if we have no fill\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\t// set canvas text styles\n\t\t\tlet fillStyle = style.fill;\n\t\t\tif (typeof fillStyle === \"number\") {\n\t\t\t\tfillStyle = PIXI.utils.hex2string(fillStyle);\n\t\t\t} else if (Array.isArray(fillStyle)) {\n\t\t\t\tfor (let i = 0; i < fillStyle.length; i++) {\n\t\t\t\t\tlet fill = fillStyle[i];\n\t\t\t\t\tif (typeof fill === \"number\") {\n\t\t\t\t\t\tfillStyle[i] = PIXI.utils.hex2string(fill);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.context.fillStyle = this._generateFillStyle(new PIXI.TextStyle(style), [text]) as string | CanvasGradient;\n\t\t\t// Typecast required for proper typechecking\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\t// Fourth pass: collect the bounding boxes and draw the debug information\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tlet offset = -this._style.padding - this.getDropShadowPadding();\n\n\t\t\tthis.hitboxes.push({\n\t\t\t\ttag,\n\t\t\t\thitbox: new PIXI.Rectangle(x + offset, y - ascent + offset, width, ascent + descent)\n\t\t\t});\n\n\t\t\tlet debugSpan = style.debug === undefined\n\t\t\t\t? MultiStyleText.debugOptions.spans.enabled\n\t\t\t\t: style.debug;\n\n\t\t\tif (debugSpan) {\n\t\t\t\tthis.context.lineWidth = 1;\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bounding) {\n\t\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.rect(x, y - ascent, width, ascent + descent);\n\t\t\t\t\tthis.context.fill();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t\tthis.context.stroke(); // yes, twice\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.baseline) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.baseline;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y);\n\t\t\t\t\tthis.context.lineTo(x + width, y);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.top) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.top;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y - ascent);\n\t\t\t\t\tthis.context.lineTo(x + width, y - ascent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bottom) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bottom;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y + descent);\n\t\t\t\t\tthis.context.lineTo(x + width, y + descent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.text) {\n\t\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\t\tthis.context.strokeText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.fillText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (MultiStyleText.debugOptions.objects.enabled) {\n\t\t\tif (MultiStyleText.debugOptions.objects.bounding) {\n\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.objects.bounding;\n\t\t\t\tthis.context.beginPath();\n\t\t\t\tthis.context.rect(0, 0, width, height);\n\t\t\t\tthis.context.fill();\n\t\t\t}\n\n\t\t\tif (MultiStyleText.debugOptions.objects.text) {\n\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateTexture();\n\t}\n\n\tprotected wordWrap(text: string): string {\n\t\t// Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n\t\tlet result = \"\";\n\t\tlet re = this.getTagRegex(true, true);\n\n\t\tconst lines = text.split(\"\\n\");\n\t\tconst wordWrapWidth = this._style.wordWrapWidth;\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tthis.context.font = this.getFontString(this.textStyles[\"default\"]);\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet spaceLeft = wordWrapWidth;\n\t\t\tconst tagSplit = lines[i].split(re);\n\t\t\tlet firstWordOfLine = true;\n\n\t\t\tfor (let j = 0; j < tagSplit.length; j++) {\n\t\t\t\tif (re.test(tagSplit[j])) {\n\t\t\t\t\tresult += tagSplit[j];\n\t\t\t\t\tif (tagSplit[j][1] === \"/\") {\n\t\t\t\t\t\tj += 2;\n\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[tagSplit[j]]));\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tthis.context.font = this.getFontString(styleStack[styleStack.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tconst words = tagSplit[j].split(\" \");\n\n\t\t\t\t\tfor (let k = 0; k < words.length; k++) {\n\t\t\t\t\t\tconst wordWidth = this.context.measureText(words[k]).width;\n\n\t\t\t\t\t\tif (this._style.breakWords && wordWidth > spaceLeft) {\n\t\t\t\t\t\t\t// Part should be split in the middle\n\t\t\t\t\t\t\tconst characters = words[k].split('');\n\n\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\tspaceLeft -= this.context.measureText(\" \").width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (let c = 0; c < characters.length; c++) {\n\t\t\t\t\t\t\t\tconst characterWidth = this.context.measureText(characters[c]).width;\n\n\t\t\t\t\t\t\t\tif (characterWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t\tresult += `\\n${characters[c]}`;\n\t\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - characterWidth;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresult += characters[c];\n\t\t\t\t\t\t\t\t\tspaceLeft -= characterWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(this._style.breakWords) {\n\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\tspaceLeft -= wordWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst paddedWordWidth =\n\t\t\t\t\t\t\t\twordWidth + (k > 0 ? this.context.measureText(\" \").width : 0);\n\n\t\t\t\t\t\t\tif (paddedWordWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t// Skip printing the newline if it's the first word of the line that is\n\t\t\t\t\t\t\t\t// greater than the word wrap width.\n\t\t\t\t\t\t\t\tif (!firstWordOfLine) {\n\t\t\t\t\t\t\t\t\tresult += \"\\n\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - wordWidth;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tspaceLeft -= paddedWordWidth;\n\n\t\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirstWordOfLine = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tresult += '\\n';\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprotected updateTexture() {\n\t\tconst texture = this._texture;\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\ttexture.baseTexture.hasLoaded = true;\n\t\ttexture.baseTexture.resolution = this.resolution;\n\n\t\ttexture.baseTexture.realWidth = this.canvas.width;\n\t\ttexture.baseTexture.realHeight = this.canvas.height;\n\t\ttexture.baseTexture.width = this.canvas.width / this.resolution;\n\t\ttexture.baseTexture.height = this.canvas.height / this.resolution;\n\t\ttexture.trim.width = texture.frame.width = this.canvas.width / this.resolution;\n\t\ttexture.trim.height = texture.frame.height = this.canvas.height / this.resolution;\n\n\t\ttexture.trim.x = -this._style.padding - dropShadowPadding;\n\t\ttexture.trim.y = -this._style.padding - dropShadowPadding;\n\n\t\ttexture.orig.width = texture.frame.width - (this._style.padding + dropShadowPadding) * 2;\n\t\ttexture.orig.height = texture.frame.height - (this._style.padding + dropShadowPadding) * 2;\n\n\t\t// call sprite onTextureUpdate to update scale if _width or _height were set\n\t\tthis._onTextureUpdate();\n\n\t\ttexture.baseTexture.emit('update', texture.baseTexture);\n\n\t\tthis.dirty = false;\n\t}\n\n\t// Lazy fill for Object.assign\n\tprivate assign(destination: any, ...sources: any[]): any {\n\t\tfor (let source of sources) {\n\t\t\tfor (let key in source) {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t}\n\n\t\treturn destination;\n\t}\n}\n"],"names":["INTERACTION_EVENTS","TAG_STYLE","TAG","bbcode","xml","text","styles","_super","_this","forEach","event","on","e","handleInteraction","__extends","MultiStyleText","ev","localPoint","data","getLocalPosition","this","targetTag","hitboxes","reduce","prev","hitbox","undefined","contains","x","y","tag","Object","style","textStyles","assign","DEFAULT_TAG_STYLE","default","tagStyle","b","fontStyle","i","color","fill","outline","stroke","strokeThickness","font","fontFamily","shadow","dropShadowColor","dropShadow","dropShadowBlur","dropShadowDistance","dropShadowAngle","size","fontSize","spacing","letterSpacing","align","_style","PIXI","TextStyle","dirty","captureName","captureMatch","tagAlternation","keys","join","reStr","RegExp","lines","outputTextData","re","getTagRegex","styleStack","tagStack","name","properties","length","lineTextData","matches","matchArray","exec","push","createTextData","currentSearchIdx","j","index","this_1","substring","pop","propertyRegex","getPropertyRegex","propertyMatch","includes","bbcodeTags_1","getBBcodePropertyRegex","bbStyle_1","entries","result","map","match","toFontString","width","height","fontProperties","maxDistance","maxBlur","styleKey","_a","Math","max","texture","baseTexture","resolution","outputText","wordWrap","split","_getTextDataPerLine","lineWidths","lineYMins","lineYMaxs","maxLineWidth","lineWidth","lineYMin","lineYMax","sty","context","getFontString","measureText","TextMetrics","measureFont","valign","min","descent","ascent","maxStrokeThickness","key","cur","dropShadowPadding","getDropShadowPadding","canvas","scale","textBaseline","lineJoin","basePositionY","drawingData","line","linePositionX","width_1","linePositionY","k","charWidth","charAt","save","dropFillStyle","utils","hex2string","shadowColor","shadowBlur","shadowOffsetX","cos","shadowOffsetY","sin","fillText","restore","strokeStyle","strokeText","fillStyle","Array","isArray","_generateFillStyle","offset","padding","Rectangle","debug","debugOptions","spans","enabled","bounding","beginPath","rect","baseline","moveTo","lineTo","closePath","top","bottom","toFixed","objects","updateTexture","wordWrapWidth","spaceLeft","tagSplit","firstWordOfLine","test","words","wordWidth","breakWords","characters","c","characterWidth","paddedWordWidth","_texture","hasLoaded","realWidth","realHeight","trim","frame","orig","_onTextureUpdate","emit","destination","_i","sources","sources_1","source","PI","fillGradientType","TEXT_GRADIENT","LINEAR_VERTICAL","fontVariant","fontWeight","lineHeight","miterLimit","Text"],"mappings":"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"}